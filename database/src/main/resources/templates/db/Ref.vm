#set($names             = ${model.dataSet.names})
#set($filename          = ${model.javaName} + "Ref")
#set($package           = ${model.package})
#set($clsDataSet        = ${model.dataSet.name} + "DataSet")
#set($clsRef            = ${model.javaName} + "Ref")
#set($clsTable          = ${names.getTableClass($model)})
#set($clsRowbuilder     = ${names.getRowBuilderClass($model)})
#set($jdSep             = "#")
#set($privateListPrefix = "private_")
#if( $package && $package.length() != 0 )
package ${package};
#end

import com.seitenbau.testing.dbunit.dsl.DataSetIdentificator;
import com.seitenbau.testing.dbunit.dsl.DataSetRegistry;

import java.util.HashMap;
import java.util.Map;
import com.seitenbau.testing.dbunit.dsl.DatabaseRef;

import ${model.package}.${clsTable}.${clsRowbuilder};


/**
 * Reference ("Ref") to a ${model.javaName} table row. Once bound to a table 
 * {@link ${clsTable}${jdSep}${clsRowbuilder}}, the Ref can be used instead
 * of the concrete rowbuilder.  
 * <p>
 * Available fields:
 * <ul>
#foreach ($col in $model.columns)
 *   <li>{@link ${jdSep}get${col.javaName}()} - ${col.javaType}
#if( ${col.description} )
   *    <br>${col.description}
#end
 *   </li>
#end
 * </ul>
 * <p>
 * Available relations:
 * <ul>
#foreach( $rel in ${model.manyToOneRelations} )
 *   <li>{@link ${jdSep}${rel.localName}(${rel.otherRefClass})}</li>
#end
#foreach( $rel in ${model.oneToManyRelations} )
 *   <li>{@link ${jdSep}${rel.localName}(${rel.otherRefClass} ... )}</li>
#end
#foreach ( $rel in ${model.associativeRelations} )
 *   <li>{@link ${jdSep}${rel.localName}(${rel.otherRefClass} ... )}</li>
#end
 * </ul>
 */
public class ${clsRef} extends DatabaseRef
{

  private final Map<${clsDataSet}, ${clsRowbuilder}> builders;
  
  public ${clsRef}()
  {
    builders = new HashMap<${clsDataSet}, ${clsRowbuilder}>();
  }
#foreach ($col in $model.columns)

#if( ${col.description} )
  /**
   * ${col.description}
   * @return The value
   */
#end
  public ${col.javaType} get${col.javaName}()
  {
    return getCurrentBuilder().get${col.javaName}();
  } 
#end

  /**
   * Allows to access the bound row builder depending on the active DataSet
   * @return The Rowbuilder in the current DataSet
   */
  public ${clsRowbuilder} getCurrentBuilder()
  {
    ${clsRowbuilder} row = builders.get(getActiveDataSet());
    if (row == null)
    {
      throw new IllegalStateException("No corresponding row builder found in ${clsRef}");
    }
    return row;
  }

  public void removeFromDataSet()
  {
    ${clsDataSet} dataSet = getActiveDataSet();
    
    ${clsRowbuilder} rowbuilder = getBuilder(dataSet);
    if (rowbuilder == null)
    {
      // Nothing to delete...
      return;
    }

    dataSet.${names.getTableVariable($model)}.deleteRow(rowbuilder);

#foreach( $col in $model.columns )
#foreach( $refCol in $col.referencedByList )
#if( ${refCol.table.isAssociativeTable()} ) 
    dataSet.${names.getTableVariable($refCol.table)}.deleteAllAssociations(this);
#else
    if (dataSet.${names.getTableVariable($refCol.table)}.getWhere.${refCol.javaNameFirstLower}(this).isPresent())
    {
      dataSet.${names.getTableVariable($refCol.table)}.findWhere.${refCol.javaNameFirstLower}(this).set${refCol.javaName}Raw(null);
    }
#end
#end
#end

    builders.remove(dataSet.getDataSet());
  }

  void setBuilder(DataSetIdentificator identificator, ${clsRowbuilder} builder)
  {
    if (!(identificator.getDataSet() instanceof ${clsDataSet}))
    {
      throw new RuntimeException("Cannot bind ${clsRef} to " + identificator.getDataSet().getClass().getName());
    }
    
    ${clsDataSet} dataSet = (${clsDataSet})(identificator.getDataSet());
  
    ${clsRowbuilder} lastBuilder = builders.put(dataSet, builder);
    if (lastBuilder != null && lastBuilder != builder)
    {
      throw new RuntimeException("Builder cannot be redefined");
    }
#foreach( $rel in ${model.manyToOneRelations} )
#set( $map = ${privateListPrefix} + ${rel.localName} + "Map" )
#set( $refVar = ${rel.otherRefVariable})

    ${rel.otherRefClass} ${refVar} = ${map}.get(dataSet);
    if (${refVar} != null)
    {
      builder.set${rel.localColumn.javaName}(${refVar});
    }
#end
  }

  ${clsRowbuilder} getBuilder(DataSetIdentificator identificator)
  {
    return builders.get(identificator.getDataSet());
  }
#foreach( $rel in ${model.manyToOneRelations} )
#set( $map = ${privateListPrefix} + ${rel.localName} + "Map" )

  // Cache for unresolvable relations
  private Map<${clsDataSet}, ${rel.otherRefClass}> ${map} = new HashMap<${clsDataSet}, ${rel.otherRefClass}>();

  /**
#if( ${rel.description} && ${rel.description.length()} > 0 )
   * ${rel.description}
   * <p>
#end
   * Models: This entity (and maybe others) is related to the given entity ref.
   * @param ref The reference to the entity, to which the current entity is related to
   * @return The reference to the current entity
   */
  public ${clsRef} ${rel.localName}(${rel.otherRefClass} ref)
  {
    ${clsDataSet} dataSet = getActiveDataSet();
    ${clsRowbuilder} builder = getBuilder(dataSet);

    if (builder != null) {
      builder.set${rel.localColumn.javaName}(ref);
    } else {
      ${map}.put(dataSet, ref);
    }
    return this;
  }
#end
#foreach( $rel in ${model.oneToManyRelations} )

  /**
#if( ${rel.description} && ${rel.description.length()} > 0 )
   * ${rel.description}
   * <p>
#end
   * Models: This entity is related to the given entity refs.
   * @param refs A list of references, which are related to the current entity
   * @return The reference to the current entity
   */
  public ${clsRef} ${rel.localName}(${rel.otherRefClass} ... refs)
  {
    for (${rel.otherRefClass} ref : refs)
    {
      ref.${rel.otherName}(this);
    }
    return this;
  }
#end
#foreach ( $rel in ${model.associativeRelations} )
#set( $otherTable = ${names.getTableVariable(${rel.otherColumn.table})} )

  /**
#if( ${rel.description} && ${rel.description.length()} > 0 )
   * ${rel.description}
   * <p>
#end
   * Models: A n:m relationship between both entities.
   * @param refs A list of references, which are related to the current entity
   * @return The reference to the current entity
   */
  public ${clsRef} ${rel.localName}(${rel.otherRefClass} ... refs)
  {
    ${clsDataSet} dataSet = getActiveDataSet();

    for (${rel.otherRefClass} ref : refs)
    {
      ${package}.${names.getTableClass($rel.localAssociationColumn.table)}.${rel.otherRowbuilderClass} builder = dataSet.${otherTable}.insertRow();
      builder.set${rel.localAssociationColumn.javaName}(this);
      builder.set${rel.otherColumn.javaName}(ref);
    }
    return this;
  }
#end  

  private ${clsDataSet} getActiveDataSet() 
  {
    DataSetIdentificator identificator = DataSetRegistry.getCurrentDataSet("${model.package}.${model.dataSet.name}");
    if (identificator == null)
    {
      throw new IllegalStateException("No active context set in ${names.getRefClass($model)}");
    }
    return (${clsDataSet})identificator.getDataSet();
  }

}
