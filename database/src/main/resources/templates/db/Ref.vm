#set($names             = ${model.dataSet.names})
#set($filename          = ${model.javaName} + "Ref")
#set($package           = ${model.package})
#set($clsDataSet        = ${model.dataSet.name} + "DataSet")
#set($clsRef            = ${model.javaName} + "Ref")
#set($clsTable          = ${names.getTableClass($model)})
#set($clsRowbuilder     = ${names.getRowBuilderClass($model)})
#set($jdSep             = "#")
#set($privateListPrefix = "private_")
#if( $package && $package.length() != 0 )
package ${package};
#end

import com.seitenbau.testing.dbunit.dsl.DataSetIdentificator;
import com.seitenbau.testing.dbunit.dsl.DataSetRegistry;

import java.util.HashMap;
import java.util.Map;
import com.seitenbau.testing.dbunit.dsl.DatabaseRef;

import ${model.package}.${clsTable}.${clsRowbuilder};


/**
 * Reference ("Ref") to a ${model.javaName} table row. Once bound to a table 
 * {@link ${clsTable}${jdSep}${clsRowbuilder}}, the Ref can be used instead
 * of the concrete rowbuilder.  
 * <p>
 * Available fields:
 * <ul>
#foreach ($col in $model.columns)
 *   <li>get${col.javaName}() - ${col.javaType}
#if( ${col.description} )
   *    <br>${col.description}
#end
 *   </li>
#end
 * </ul>
 */
public class ${clsRef} extends DatabaseRef
{

  private final Map<Object, ${clsRowbuilder}> builders;
  
  public ${clsRef}()
  {
    builders = new HashMap<Object, ${clsRowbuilder}>();
  }
#foreach ($col in $model.columns)

#if( ${col.description} )
  /**
   * ${col.description}
   * @return The value
   */
#end
  public ${col.javaType} get${col.javaName}()
  {
    final ${clsDataSet} dataSet = getActiveDataSet();
    final ${clsRowbuilder} row = builders.get(dataSet);
    if (row == null)
    {
      throw new IllegalStateException("No corresponding row to query ${col.javaName} in ${model.javaName}Ref");
    }
    return row.get${col.javaName}();
  } 
#end

  public void removeFromDataSet()
  {
    ${clsDataSet} dataSet = getActiveDataSet();
    
    ${clsRowbuilder} rowbuilder = getBuilder(dataSet);
    if (rowbuilder == null)
    {
      // Nothing to delete...
      return;
    }

    dataSet.${names.getTableVariable($model)}.deleteRow(rowbuilder);

#foreach( $col in $model.columns )
#foreach( $refCol in $col.referencedByList )
#if( ${refCol.table.isAssociativeTable()} ) 
    dataSet.${names.getTableVariable($refCol.table)}.deleteAllAssociations(this);
#else
    if (dataSet.${names.getTableVariable($refCol.table)}.getWhere.${refCol.javaNameFirstLower}(this).isPresent())
    {
      dataSet.${names.getTableVariable($refCol.table)}.findWhere.${refCol.javaNameFirstLower}(this).set${refCol.javaName}Raw(null);
    }
#end
#end
#end

    builders.remove(dataSet.getDataSet());
  }

  void setBuilder(DataSetIdentificator identificator, ${clsRowbuilder} builder)
  {
    if (!(identificator.getDataSet() instanceof ${clsDataSet}))
    {
      throw new RuntimeException("Cannot bind ${clsRef} to " + identificator.getDataSet().getClass().getName());
    }
    
    ${clsDataSet} dataSet = (${clsDataSet})(identificator.getDataSet());
  
    ${clsRowbuilder} lastBuilder = builders.put(dataSet, builder);
    if (lastBuilder != null && lastBuilder != builder)
    {
      throw new RuntimeException("Builder cannot be redefined");
    }
#foreach( $rel in ${model.manyToOneRelations} )
#set( $map = ${privateListPrefix} + ${rel.localName} + "Map" )
#set( $refVar = ${rel.otherRefVariable})

    ${rel.otherRefClass} ${refVar} = ${map}.get(dataSet);
    if (${refVar} != null)
    {
      builder.set${rel.localColumn.javaName}(${refVar});
    }
#end
  }

  ${clsRowbuilder} getBuilder(DataSetIdentificator identificator)
  {
    return builders.get(identificator.getDataSet());
  }

#foreach( $rel in ${model.manyToOneRelations} )
#set( $map = ${privateListPrefix} + ${rel.localName} + "Map" )

  // Cache for unresolvable relations
  private Map<${clsDataSet}, ${rel.otherRefClass}> ${map} = new HashMap<${clsDataSet}, ${rel.otherRefClass}>();

  /**
   * TODO
   * ManyToOne
   */
  public ${clsRef} ${rel.localName}(${rel.otherRefClass} ref)
  {
    ${clsDataSet} dataSet = getActiveDataSet();
    ${clsRowbuilder} builder = getBuilder(dataSet);

    if (builder != null) {
      builder.set${rel.localColumn.javaName}(ref);
    } else {
      ${map}.put(dataSet, ref);
    }
    return this;
  }
#end
#foreach( $rel in ${model.oneToManyRelations} )

  /**
   * TODO
   * One To Many
   */
  public ${clsRef} ${rel.localName}(${rel.otherRefClass} ... refs)
  {
    for (${rel.otherRefClass} ref : refs)
    {
      ref.${rel.otherName}(this);
    }
    return this;
  }
#end
#foreach ( $rel in ${model.associativeRelations} )
#set( $otherTable = ${names.getTableVariable(${rel.otherColumn.table})} )

  /**
   * TODO
   * Associative Relation
   */
  public ${clsRef} ${rel.localName}(${rel.otherRefClass} ... refs)
  {
    ${clsDataSet} dataSet = getActiveDataSet();

    for (${rel.otherRefClass} ref : refs)
    {
      ${package}.${names.getTableClass($rel.localAssociationColumn.table)}.${rel.otherRowbuilderClass} builder = dataSet.${otherTable}.insertRow();
      builder.set${rel.localAssociationColumn.javaName}(this);
      builder.set${rel.otherColumn.javaName}(ref);
    }
    return this;
  }
#end  

  private ${clsDataSet} getActiveDataSet() 
  {
    DataSetIdentificator identificator = DataSetRegistry.getCurrentDataSet("${model.package}.${model.dataSet.name}");
    if (identificator == null)
    {
      throw new IllegalStateException("No active context set in ${names.getRefClass($model)}");
    }
    return (${clsDataSet})identificator.getDataSet();
  }

}
