#set($filename = ${model.name} + "Builder" )
#set($package  = ${model.package} )
#set($clsBuilder = ${model.name} + "Builder")
#set($clsDataSet = ${model.name} + "DataSet")
#set($referenceMethod = "ref")
#if( $package && $package.length() != 0 )
package ${package};
#end

import com.seitenbau.testing.dbunit.extend.DbUnitDatasetFactory;
import com.seitenbau.testing.dbunit.dsl.DataSetIdentificator;
import com.seitenbau.testing.dbunit.dsl.DataSetRegistry;
import org.dbunit.dataset.IDataSet;

#if( $model.package && $model.package.length() != 0 )
import ${model.package}.${clsDataSet};
#end
#foreach( $table in $model.tables )
import ${model.package}.${table.javaName}Ref;
import ${model.package}.${table.javaName}Table.RowBuilder_${table.javaName};
#end

import groovy.lang.Closure;

import java.util.List;

/**
 * Represents a ${model.name} Data Set Scope. Parses the DSL and builds
 * the datasets
 */
public class ${clsBuilder} implements DataSetIdentificator, DbUnitDatasetFactory
{

  private final ${clsDataSet} dataset;

#foreach( $table in $model.tables )
  /**
   * ${table.description}
   */
  public final ${table.javaName}TableAdapter ${table.javaNameFirstLower}Table;
  
  // Getter for Groovy property access
  protected ${table.javaName}TableAdapter get${table.javaName}Table()
  {
    return ${table.javaNameFirstLower}Table;
  }
#end

  private static ThreadLocal<${clsBuilder}> activeParents = new ThreadLocal<${clsBuilder}>();

  private static void unsetActiveParent()
  {
    activeParents.remove();
  }

  private static boolean trySetActiveParent(${clsBuilder} instance)
  {
    // there is a thread local active parent, so do not allow to overwrite it
    if (activeParents.get() != null) {
      return false;
    }
    
    activeParents.set(instance);
    return true;
  }

  private static ${clsBuilder} getWorkingInstance(${clsBuilder} current)
  {
    if (activeParents.get() != null)
    {
      return activeParents.get();
    }
    
    return current;
  }

  public ${clsBuilder}() {
    this(new ${clsDataSet}() 
    {
      @Override
      public void initDataSet() { }
    });
  }
  
  public ${clsBuilder}($clsDataSet dataset)
  {
    ${clsBuilder} instance = getWorkingInstance(null);
    if (getWorkingInstance(null) == null) {
      // no other parent active, create tables
      this.dataset = dataset;
#foreach( $table in $model.tables )
      ${table.javaNameFirstLower}Table = new ${table.javaName}TableAdapter(this, dataset.table_${table.javaName});
#end
    } else {
      // use parent's tables
      this.dataset = instance.dataset;
#foreach( $table in $model.tables )
      ${table.javaNameFirstLower}Table = instance.${table.javaNameFirstLower}Table;
#end
    }

    buildDataSet(getWorkingInstance(this));
  }
  
  private void buildDataSet(${clsBuilder} instance)
  {
    DataSetIdentificator lastDataSet = DataSetRegistry.use(instance);
    handleExtensions();
    tables();
    relations();
    DataSetRegistry.use(lastDataSet);
  }
  
  private void handleExtensions()
  {
    handleExtendsDataSet(extendsDataSet());
    if (extendsDataSets() != null) {
      List<?> dataSets = (List<?>)extendsDataSets();
      for (Object dataSet : dataSets)
      {
        handleExtendsDataSet(dataSet);
      }
    }
  }
  
  private void handleExtendsDataSet(Object dataSet)
  {
    if (dataSet == null)
    {
      return;
    }
    if (!(dataSet instanceof java.lang.Class))
    {
      throw new RuntimeException("Wrong type");
    }
    
    Class<?> clazz = (Class<?>)dataSet;
    if (!(hasSuperClass(clazz, ${clsBuilder}.class)))
    {
      throw new RuntimeException("Wrong type");
    }

    try
    {
      boolean hasSet = trySetActiveParent(this);
      clazz.newInstance();
      if (hasSet) {
        unsetActiveParent();
      }
    }
    catch (Exception e)
    {
      throw new RuntimeException("Error extending builder", e);
    }
  }

  private boolean hasSuperClass(Class<?> clazz, Class<?> superClass)
  {
    Class<?> c = clazz;
    while (c != null)
    {
      if (superClass.equals(c)) 
      {
        return true;
      }
      c = c.getSuperclass();
    }
    return false;
  }

  /**
   * Template method to define the tables test data.
   */
  protected Object tables()
  {
    return null;
  }

  /**
   * Template method to define the relations.
   */
  protected Object relations()
  {
    return null;
  }

  protected Object extendsDataSet() 
  {
    return null;
  }

  protected Object extendsDataSets() 
  {
    return null;
  }

  /**
   * Parses and integrates the tables to the data set
   * Supported tables:
   * <ul>
#foreach( $table in $model.tables )
   *   <li>{@code ${table.javaNameFirstLower}Table} - ${table.description}</li>
#end
   * </ul>
   *  
   * @param table Table data
   */
  public void tables(Closure<?> table)
  {
    tables(getWorkingInstance(this), table);
  }

  /**
   * Parses and integrates the tables to a given data set
   * Supported tables:
   * <ul>
#foreach( $table in $model.tables )
   *   <li>{@code ${table.javaNameFirstLower}Table} - ${table.description}</li>
#end
   * </ul>
   *
   * @param table Table data
   */
  public void tables(${clsBuilder} dataSet, Closure<?> table)
  {
    DataSetIdentificator lastDataSet = DataSetRegistry.use(dataSet);
    table.setDelegate(dataSet);
    table.setResolveStrategy(Closure.DELEGATE_FIRST);
    table.call();
    DataSetRegistry.use(lastDataSet);
  }

  /**
   * Parses the defined relations and integrates them into the data set
   * @param relations The relations data
   */
  public void relations(Closure<?> relations)
  {
    this.relations(getWorkingInstance(this), relations);
  }

  /**
   * Parses the defined relations and integrates them into a given data set
   * @param relations The relations data
   */
  public void relations(${clsBuilder} dataSet, Closure<?> relations)
  {
    DataSetIdentificator lastDataSet = DataSetRegistry.use(dataSet);
    relations.call();
    DataSetRegistry.use(lastDataSet);
  }

#foreach( $table in $model.tables )
#set($clsRef = ${table.javaName} + "Ref")
#set($clsRefAccess = ${table.javaName} + "RefAccess")
#set($varTable = ${table.javaNameFirstLower} + "Table")

  /**
   * Allows ${table.javaName} table data access using references
   * @param ref The reference which represents tha data
   * @return The accessor object 
   */
  public RowBuilder_${table.javaName} ${referenceMethod}(${clsRef} ref)
  {
    return ref.getBuilder(this);
  }
#end

  @Override
  public String getDataSetClassName()
  {
    return dataset.getDataSetClassName();
  }
  
  @Override
  public Object getDataSet()
  {
    return dataset.getDataSet();
  } 

  /**
   * Create a DBUnit dataset.
   * @return The Dbunit dataset
   */
  @Override
  public IDataSet createDBUnitDataSet() 
  {
    return dataset.createDBUnitDataSet();
  }

}