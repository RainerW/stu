#set($filename = ${model.javaName} + "Table" )
#if( $model.package && $model.package.length() != 0 )
#set($package  = ${model.package} + ".dsl" )
#else
#set($package  = "dsl" )
#end
#set($clsScope = ${model.dataSet.name} + "Builder")
#set($clsRowbuilder = "RowBuilder_" + ${model.javaName})
#set($clsExtRowbuilder = "Extended" + ${clsRowbuilder})
#set($clsWhere = ${model.javaName} + "GetWhere")
#set($clsRef = ${model.javaName} + "Ref")
#set($clsTable = ${model.javaName} + "Table")
#set($clsTableFindWhere = ${model.javaName} + "TableFindWhere")
#set($clsTableGetWhere = ${model.javaName} + "TableGetWhere")
#set($clsRowcollection= "RowCollection_" + ${model.javaName} )
package ${package};

import com.google.common.base.Optional;

import com.seitenbau.testing.dbunit.dsl.CastUtil;
import com.seitenbau.testing.dbunit.dsl.ColumnBinding;
import com.seitenbau.testing.dbunit.dsl.DatabaseReference;
import com.seitenbau.testing.dbunit.dsl.TableParserCallback;
import com.seitenbau.testing.dbunit.dsl.ITableAdapter;
import com.seitenbau.testing.dbunit.dsl.LazyValue;
import com.seitenbau.testing.dbunit.dsl.NoValue;
import com.seitenbau.testing.dbunit.dsl.TableParser;
import com.seitenbau.testing.dbunit.generator.DataType;
import com.seitenbau.testing.dbunit.modifier.IDataSetModifier;
import com.seitenbau.testing.dbunit.util.NullCompatibleEquivalence;
import com.seitenbau.testing.util.date.DateBuilder;
import com.seitenbau.testing.util.Action;
import com.seitenbau.testing.util.Filter;

import groovy.lang.Closure;

import java.util.HashSet;
import java.util.Set;


###if( $model.package && $model.package.length() != 0 )
##import ${model.package}.${model.dataSet.name}DataSet;
###end
import ${model.package}.${clsTable}.${clsWhere};
import ${model.package}.${clsTable}.${clsRowcollection};
import ${model.package}.${model.javaName}Model;
#foreach( $table in $model.dataSet.tables )
import ${model.package}.${table.javaName}Table.RowBuilder_${table.javaName};
import ${model.package}.${table.javaName}Table.RowGetters_${table.javaName};
#end

public class ${clsTable} {

  /**
   * Do not set a value. (To remove a value use <i>null</i>)
   */
  public final NoValue _ = new NoValue();

  /**
   * Column Header for ${model.javaName} table.
   * <p>
   * Data Type: ${model.javaName}Ref
   */
  public final ColumnBinding<${clsRowbuilder}, ${clsWhere}> REF = createREFBinding();

#foreach( $col in $model.columns )
#macro( comments )
  /**
   * Column Header for ${model.javaName} table.
#if( ${col.description} )
   * <p>
   * ${col.description}
#end
   * <p>
   * Data Type: {@code ${col.javaType}}
#if( ${col.reference} )
   * or {@code ${col.reference.column.table.javaName}Ref}  
#end
   * <br>   
   * Database Type: ${col.type}
   * 
   */
#end
#comments()   
  public final ColumnBinding<${clsRowbuilder}, ${clsWhere}> ${col.name} = create${col.javaName}Binding();

## check if column is an identifier
#if ( ${col.truncatedReferenceName} )
#set( $shortname  = ${col.truncatedReferenceName} )
#comments()   
  public final ColumnBinding<${clsRowbuilder}, ${clsWhere}> ${shortname} = ${col.name};

#end
#end
  private final ${clsScope} _scope;

  private final ${model.package}.${clsTable} _table;

  private final ITableAdapter<${clsRowbuilder}, ${clsWhere}, ${clsRef}> _adapter = new TableAdapter();
    
  ${clsTable}(${clsScope} scope, ${model.package}.${clsTable} table)
  {
    _scope = scope;
    _table = table;
  }
  
  ${model.package}.${clsTable} getTableModel()
  {
    return _table;
  }
  
  /**
   * Parses the rows of a ${model.javaName} table. Supported columns are:
   * <ul>
   *   <li><strong>{@code REF}</strong>: {@code ${model.javaName}Ref}</li>
#foreach( $col in $model.columns )
#set( $shortname  = "" )
#if ( ${col.truncatedReferenceName} )
#set( $shortname  = " (alias: <strong>{@code " + ${col.truncatedReferenceName} + "}</strong>)")
#end
   *   <li> <strong>{@code ${col.name}}</strong>$shortname: {@code ${col.javaType}}
#end
   * </ul>
   * @param rows The table data
   */
  public void rows(Closure<?> rows)
  {
    TableParserCallback<${clsRowbuilder}, ${clsWhere}, ${clsRef}> callback = 
        new TableParserCallback<${clsRowbuilder}, ${clsWhere}, ${clsRef}>(_adapter);
    TableParser.parseTable(rows, this, callback);
  }
  
  public int getRowCount() 
  {
    return _table.getRowCount();
  }
  

  private boolean valueMustBeSetRaw(Object value)
  {
    return (value instanceof DatabaseReference) || (value instanceof IDataSetModifier);
  }
  
  private class TableAdapter implements ITableAdapter<${clsRowbuilder}, ${clsWhere}, ${clsRef}>
  {
    public ${clsRowbuilder} insertRow() 
    {
      return _table.insertRow();
    }
  
    public ${clsWhere} getWhere()
    {
      return _table.getWhere;
    }
    
    public void bindToScope(${clsRef} reference, ${clsRowbuilder} row)
    {
      reference.setBuilder(_scope, row);
    }

    public void handleReferences(${clsRef} reference, ${clsRowbuilder} row)
    {
      _scope.replace${clsRef}WithId(reference, row);
    }    

    public ${clsRowbuilder} getRowByReference(${clsRef} reference)
    {
      return reference.getBuilder(_scope);
    }

    public String getTableName()
    {
      return "${model.javaName}";
    }
    
  };  

  private ColumnBinding<${clsRowbuilder}, ${clsWhere}> createREFBinding()
  {
    return new ColumnBinding<${clsRowbuilder}, ${clsWhere}>()
    { 
      @Override
      public void set(${clsRowbuilder} row, Object value)
      {
        throw new RuntimeException("Setting on REF is not allowed");
      }
    
      @Override
      public boolean isRefColumn() 
      {
        return true;
      }

      @Override
      public DataType getDataType() 
      {
        return null;
      }
    };
  }
#foreach( $col in $model.columns )

  private ColumnBinding<${clsRowbuilder}, ${clsWhere}> create${col.javaName}Binding() 
  {
    return new ColumnBinding<${clsRowbuilder}, ${clsWhere}>()
    {
      @Override
      public void set(${clsRowbuilder} row, Object value)
      {
#if ( ${col.isIdentifierColumn()} )
        if (definedIdsSet.contains(row) && !NullCompatibleEquivalence.equals(row.get${col.javaName}(), value)) {
          throw new IllegalStateException("Cannot reset column id [" + row.get${col.javaName}() + " vs " + value + "]");
        }
        definedIdsSet.add(row);
#end
        if (valueMustBeSetRaw(value)) 
        {
          row.set${col.javaName}Raw(value);
        } else {
          row.set${col.javaName}((${col.javaType})CastUtil.cast(value, ${col.type}));
        }
      }
#if ( ${col.reference} )

      @Override
      public void setReference(${clsRowbuilder} row, DatabaseReference ref)
      {
        ${col.reference.table.javaName}Ref reference = (${col.reference.table.javaName}Ref)ref;
        RowBuilder_${col.reference.table.javaName} referenceBuilder = reference.getBuilder(_scope);
        if (referenceBuilder != null)
        {
          final ${col.reference.column.javaType} value = referenceBuilder.get${col.reference.javaName}();
          row.set${col.javaName}(value);
        } else {
          row.set${col.javaName}Raw(ref);
        }
      }
#end
#if ( ${col.isIdentifierColumn()} )

      @Override
      public Optional<${clsRowbuilder}> getWhere(${clsWhere} getWhere, Object value)
      {
        return getWhere.${col.javaNameFirstLower}((${col.javaType})CastUtil.cast(value, ${col.type}));
      }

      @Override
      public boolean isIdentifierColumn()
      {
        return true;
      }
    
      private Set<${clsRowbuilder}> definedIdsSet = new HashSet<${clsRowbuilder}>();
#else

      @Override
      public void setLazyValue(${clsRowbuilder} row, LazyValue lazyValue)
      {
        row.set${col.javaName}Raw(lazyValue);
      }
#end
      
      @Override
      public DataType getDataType()
      {
        return ${col.type};
      }

    };
  }
#end

  public ${clsExtRowbuilder} insertRow()
  {
    return new ${clsExtRowbuilder}(this, _table.insertRow());
  }

  public ${clsExtRowbuilder} insertRow(${model.javaName}Model row)
  {
    return new ${clsExtRowbuilder}(this, _table.insertRow(row));
  }

  public ${clsExtRowbuilder} insertRowAt(int index)
  {
    return new ${clsExtRowbuilder}(this, _table.insertRowAt(index));
  }

  public ${clsExtRowbuilder} insertRow(${clsRowbuilder} theRow)
  {
    return new ${clsExtRowbuilder}(this, _table.insertRow(theRow));
  }
  
  public static class ${clsExtRowbuilder} implements ${clsRowbuilder}
  {
  
    private final ${clsTable} _parent;
    
    private final ${clsRowbuilder} _delegate;
  
    ${clsExtRowbuilder}(${clsTable} parent, ${clsRowbuilder} delegate)
    {
      _parent = parent;
      _delegate = delegate;
    }

#foreach( $column in $model.columns )
#if( $column.javaType.contains("Date") )

    public ${clsExtRowbuilder} set${column.javaName}(String dateString)
    {
      _delegate.set${column.javaName}(dateString);
      return this;
    }

    public ${clsExtRowbuilder} set${column.javaName}(DateBuilder date)
    {
      _delegate.set${column.javaName}(date);
      return this;
    }
#end
#if( $column.javaType.contains("Long") )

    public ${clsExtRowbuilder} set${column.javaName}(Integer intValue)
    {
      _delegate.set${column.javaName}(intValue);
      return this;
    }
#end

    public ${clsExtRowbuilder} set${column.javaName}(${column.javaType} value)
    {
      _delegate.set${column.javaName}(value);
      return this;
    }

    public ${clsExtRowbuilder} set${column.javaName}Raw(Object value)
    {
      _delegate.set${column.javaName}Raw(value);
      return this;
    }
    #if( $column.isNextIdMethodGenerated() )

    public ${clsExtRowbuilder} next${column.javaName}()
    {
      _delegate.next${column.javaName}();
      return this;
    }
#end

    public ${column.javaType} get${column.javaName}()
    {
      return _delegate.get${column.javaName}();
    }

    public Object get${column.javaName}Raw()
    {
      return _delegate.get${column.javaName}Raw();
    }
#end     
  
#foreach( $column in $model.columns )
#if( $column.reference )

    public ${clsExtRowbuilder} set${column.javaName}(${column.reference.table.javaName}Ref reference)
    {
      // TODO _delegate.set${column.javaName}( ... ) 
      RowBuilder_${column.reference.table.javaName} builder = reference.getBuilder(_parent._scope);
      if (builder == null) 
      {
        throw new IllegalArgumentException("Reference is not defined in this scope");
      }
      _delegate.ref${column.javaName}(builder);
      return this;
    }
#end
#end

    public ${clsExtRowbuilder} insertRow()
    {
      return _parent.insertRow();
    }
    
    public ${clsExtRowbuilder} insertRow(${model.javaName}Model row)
    {
      return _parent.insertRow(row); 
    }

    public ${clsExtRowbuilder} insertRowAt(int index)
    {
      return _parent.insertRowAt(index);
    }

    public ${clsExtRowbuilder} insertRow(${clsRowbuilder} theRow)
    {
      return _parent.insertRow(theRow);
    }
    
    public Object getValue(String column) throws RuntimeException {
      return _delegate.getValue(column);
    }

#foreach( $column in $model.columns )
#if( $column.reference )
#set($otherGetter  = "RowGetters_" + ${column.reference.table.javaName} )

    public ${clsExtRowbuilder} ref${column.javaName}($otherGetter reference)
    {
      _delegate.ref${column.javaName}(reference);
      return this;
    }
#end
#end
    
    @Override
    public ${clsExtRowbuilder} clone() {
      ${clsRowbuilder} cloneDelegate = _delegate.clone();
      ${clsExtRowbuilder} clone = new ${clsExtRowbuilder}(_parent, cloneDelegate);
      return clone;
    }

  }

  /**
   * Delivers a collection of rows matching to a filter
   * @param filter The used filter
   * @return The collection of rows, may return an empty list
   */
  public ${clsRowcollection} find(Filter<${clsRowbuilder}> filter)
  {
    return _table.find(filter);
  }

  /**
   * Delivers a collection of rows matching to a filter
   * @param filter A Groovy Closure with an argument of type ${clsRowbuilder}, returning a boolean
   * @return The collection of rows, may return an empty list
   */
  public ${clsRowcollection} find(Closure<Boolean> filter)
  {
    final Closure<Boolean> localFilter = filter;
    return _table.find(new Filter<${clsRowbuilder}>()
      {
        @Override
        public boolean accept(${clsRowbuilder} row)
        {
          return localFilter.call(row);
        }
      });
  }
  
  public void foreach(Closure<?> action)
  {
    final Closure<?> localAction = action;
    _table.foreach(new Action<${clsRowbuilder}>()
      {
        @Override
        public void call(${clsRowbuilder} row)
        {
          localAction.call(row);
        }
      });
  }
  
  
  public final ${clsTableFindWhere} findWhere = new ${clsTableFindWhere}(this);

  public static class ${clsTableFindWhere}
  {
   
    private final ${clsTable} table;
    
    ${clsTableFindWhere}(${clsTable} table) 
    {
      this.table = table;
    }
#foreach( $col in $model.columns )

    public ${clsRowcollection} ${col.javaNameFirstLower}(${clsRef} ref)
    {
      ${clsRowbuilder} builder = ref.getBuilder(table._scope);
      if (builder == null) 
      {
        throw new IllegalArgumentException("Reference is not defined in this scope");
      }
      return table.getTableModel().findWhere.${col.javaNameFirstLower}(builder.get${col.javaName}());
    }
#if( $col.reference )

    public ${clsRowcollection} ${col.javaNameFirstLower}(${col.reference.column.table.javaName}Ref ref)
    {
      RowBuilder_${col.reference.column.table.javaName} builder = ref.getBuilder(table._scope);
      if (builder == null) 
      {
        throw new IllegalArgumentException("Reference is not defined in this scope");
      }
      return table.getTableModel().findWhere.${col.javaNameFirstLower}(builder.get${col.reference.column.javaName}());
    }
#end    
    
    public ${clsRowcollection} ${col.javaNameFirstLower}(${col.javaType} toSearch)
    {
      return table.getTableModel().findWhere.${col.javaNameFirstLower}(toSearch);
    }
#if( $col.javaType.contains("Long") )

    public ${clsRowcollection} ${col.javaNameFirstLower}(Integer toSearch) 
    {
      return ${col.javaNameFirstLower}(Long.valueOf(toSearch));
    }
#end
#end
  }
  
  public final ${clsTableGetWhere} getWhere = new ${clsTableGetWhere}(this);

  public static class ${clsTableGetWhere}
  {

    private final ${clsTable} table;
    
    ${clsTableGetWhere}(${clsTable} table) 
    {
      this.table = table;
    }
#foreach( $col in $model.columns )

    public Optional<${clsRowbuilder}> ${col.javaNameFirstLower}(${clsRef} ref)
    {
      ${clsRowbuilder} builder = ref.getBuilder(table._scope);
      if (builder == null) 
      {
        throw new IllegalArgumentException("Reference is not defined in this scope");
      }
      return table.getTableModel().getWhere.${col.javaNameFirstLower}(builder.get${col.javaName}());
    }
#if( $col.reference )

    public Optional<${clsRowbuilder}> ${col.javaNameFirstLower}(${col.reference.column.table.javaName}Ref ref)
    {
      RowBuilder_${col.reference.column.table.javaName} builder = ref.getBuilder(table._scope);
      if (builder == null) 
      {
        throw new IllegalArgumentException("Reference is not defined in this scope");
      }
      return table.getTableModel().getWhere.${col.javaNameFirstLower}(builder.get${col.reference.column.javaName}());
    }
#end    

    public Optional<${clsRowbuilder}> ${col.javaNameFirstLower}(${col.javaType} toSearch)
    {
      return table.getTableModel().getWhere.${col.javaNameFirstLower}(toSearch);
    }
#if( $col.javaType.contains("Long") )

    public Optional<${clsRowbuilder}> ${col.javaNameFirstLower}(Integer toSearch) 
    {
      return ${col.javaNameFirstLower}(Long.valueOf(toSearch));
    }
#end
#end
  }
}

