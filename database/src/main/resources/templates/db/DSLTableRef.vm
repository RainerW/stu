#set($filename = ${model.javaName} + "Ref" )
#if( $model.package && $model.package.length() != 0 )
#set($package  = ${model.package} + ".dsl" )
#else
#set($package  = "dsl" )
#end
#set($clsScope = ${model.dataSet.name} + "DSL")
#set($clsRef = ${model.javaName} + "Ref")
#set($clsRowbuilder = "RowBuilder_" + ${model.javaName})
package ${package};

#set($utilImportsNeeded  = false )
#if ( !${model.isAssociativeTable()} )
#foreach( $col in $model.columns )
#if( $col.references && $col.references.size() != 0 )
#set($utilImportsNeeded  = true )
#end
#end
#foreach( $referencingTable in $model.dataSet.tables )
#foreach( $col in $referencingTable.columns )
#if( ${col.isReferencingTable($model)} )
#set($utilImportsNeeded  = true )
#end
#end
#end
#end

#if ( $utilImportsNeeded )
import java.util.Arrays;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;
#end
import com.seitenbau.testing.dbunit.dsl.DatabaseReference;
import ${model.package}.${model.javaName}Table.${clsRowbuilder};

public class ${clsRef} extends DatabaseReference {

  private final Map<${clsScope}, ${clsRowbuilder}> builders;
  
  public ${clsRef}()
  {
    builders = new HashMap<${clsScope}, ${clsRowbuilder}>();
  }
  
  private static final ThreadLocal<${clsScope}> threadScope = new ThreadLocal<${clsScope}>();
  
  static void setThreadLocalScope(${clsScope} scope) 
  {
    threadScope.set(scope);    
  }
  
  static void unsetThreadLocalScope() 
  {
    threadScope.remove();
  }
  
  void setBuilder(${clsScope} scope, ${clsRowbuilder} builder)
  {
    ${clsRowbuilder} lastBuilder = builders.put(scope, builder);
    if (lastBuilder != null && lastBuilder != builder) {
      throw new RuntimeException("Builder cannot be redefined");
    }
    if (lastBuilder != null) {
      System.out.println("Reference has been associated to scope");
    }
  }
  
  ${clsRowbuilder} getBuilder(${clsScope} scope)
  {
    return builders.get(scope);
  }
  
#if ( !${model.isAssociativeTable()} )
#foreach( $col in $model.columns )
#if( $col.references && $col.references.size() != 0 )
#set($methodName = ${col.reference.localName})
#set($listName = ${methodName} + "List")
#set($refRef = ${col.reference.table.javaName} + "Ref" )
  Map<${clsScope}, List<${refRef}>> ${listName} = new HashMap<${clsScope}, List<${refRef}>>();

  // depending on relation type with or without ellipse (...)
  void ${methodName}(${refRef} ... refs) {
    final List<${refRef}> list = getOrCreateList(${listName});
    list.addAll(Arrays.asList(refs));
  }

#end
#end
#foreach( $referencingTable in $model.dataSet.tables )
#foreach( $col in $referencingTable.columns )
#if( ${col.isReferencingTable($model)} )
#if ( ${referencingTable.isAssociativeTable()} )
#set( $refRef = ${referencingTable.getAssociatedTable($model).javaName} + "Ref" )
#else
#set( $refRef = ${col.table.javaName} + "Ref" )
#end
#set($methodName = ${col.reference.remoteName})
#set($listName = ${methodName} + "List")
  Map<${clsScope}, List<${refRef}>> $listName = new HashMap<${clsScope}, List<${refRef}>>();

  // depending on relation type with or with ellipse (...)
  void ${methodName}(${refRef} ... refs) {
    final List<${refRef}> list = getOrCreateList(${listName});
    list.addAll(Arrays.asList(refs));
  }

#end
#end
#end
#end

  private <T> List<T> getOrCreateList(Map<${clsScope}, List<T>> map) 
  {
    final ${clsScope} scope = threadScope.get();
    if (scope == null) {
      throw new RuntimeException("Cannot build reference out of a scope");
    }
    List<T> result = map.get(scope);
    if (result == null) 
    {
      result = new LinkedList<T>();
      map.put(scope, result);
    }
    return result;
  }
}

