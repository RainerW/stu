#set($filename = ${model.javaName} + "Ref" )
#if( $model.package && $model.package.length() != 0 )
#set($package  = ${model.package} + ".dsl" )
#else
#set($package  = "dsl" )
#end
#set($clsScope = ${model.dataSet.name} + "DSL")
#set($clsRef = ${model.javaName} + "Ref")
#set($clsRowbuilder = "RowBuilder_" + ${model.javaName})
package ${package};

#set($utilImportsNeeded  = false )
#if ( !${model.isAssociativeTable()} )
#foreach( $col in $model.columns )
#if( $col.references && $col.references.size() != 0 )
#set($utilImportsNeeded  = true )
#end
#end
#foreach( $referencingTable in $model.dataSet.tables )
#foreach( $col in $referencingTable.columns )
#if( ${col.isReferencingTable($model)} )
#set($utilImportsNeeded  = true )
#end
#end
#end
#end

#if ( $utilImportsNeeded )
import java.util.Arrays;
#end
import java.util.Iterator;
#if ( !${model.isAssociativeTable()} )
import java.util.List;
#end
import java.util.HashMap;
import java.util.Map;
import com.seitenbau.testing.dbunit.dsl.DatabaseReference;
#foreach( $table in $model.dataSet.tables )
import ${model.package}.${table.javaName}Table.RowBuilder_${table.javaName};
#end
##import ${model.package}.${model.javaName}Table.${clsRowbuilder};

public class ${clsRef} extends DatabaseReference {

  private final Map<${clsScope}, ${clsRowbuilder}> builders;
  
  public ${clsRef}()
  {
    builders = new HashMap<${clsScope}, ${clsRowbuilder}>();
  }
  
  private static final ThreadLocal<${clsScope}> threadScope = new ThreadLocal<${clsScope}>();
  
  static void setThreadLocalScope(${clsScope} scope) 
  {
    threadScope.set(scope);    
  }
  
  static void unsetThreadLocalScope() 
  {
    threadScope.remove();
  }
  
  void setBuilder(${clsScope} scope, ${clsRowbuilder} builder)
  {
    ${clsRowbuilder} lastBuilder = builders.put(scope, builder);
    if (lastBuilder != null && lastBuilder != builder) {
      throw new RuntimeException("Builder cannot be redefined");
    }
#if ( !${model.isAssociativeTable()} )
#foreach( $col in $model.columns )
#if( $col.reference )
#set($refClsRef = ${col.reference.table.javaName} + "Ref")
#set($verb = ${col.reference.localName})

    List<${refClsRef}> ${verb}ListScoped = getOrCreateList(${verb}List, threadScope);
    for (Iterator<${refClsRef}> it = ${verb}ListScoped.iterator(); it.hasNext(); )
    {
      ${refClsRef} ref = it.next();
      it.remove();	// remove iterator because if it will not resolve now, it will never
      RowBuilder_${col.reference.table.javaName} otherBuilder = ref.getBuilder(scope);
      if (otherBuilder == null) 
      {
        continue;
      }
      
      builder.set${col.javaName}(otherBuilder.get${col.reference.column.javaName}());
      List<${clsRef}> otherList = getOrCreateList(ref.${col.reference.remoteName}List, threadScope);
      if (otherList.contains(this)) 
      {
        otherList.remove(this);
      }
    }
#end
#end
#foreach( $referencingTable in $model.dataSet.tables )
#foreach( $col in $referencingTable.columns )
#if( ${col.isReferencingTable($model)} )
#if ( ${referencingTable.isAssociativeTable()} )
#set($verb = ${col.reference.remoteName})
#set($refColumn = ${referencingTable.getReferencingColumn($model)})
#set($refTable = ${refColumn.reference.table})
#set($refClsRef = ${refTable.javaName} + "Ref")

#foreach ($c in $referencingTable.columns)
#if ($c != $col)
#set($remoteKey = $c.reference.column.javaName) 
#end
#end
    List<${refClsRef}> ${verb}ListScoped = getOrCreateList(${verb}List, threadScope);
    for (Iterator<${refClsRef}> it = ${verb}ListScoped.iterator(); it.hasNext(); )
    {
      ${refClsRef} ref = it.next();
      it.remove();	// remove iterator because if it will not resolve now, it will never
      RowBuilder_${refTable.javaName} otherBuilder = ref.getBuilder(scope);
      if (otherBuilder == null) 
      {
        continue;
      }
      
      RowBuilder_${referencingTable.javaName} row = scope.${referencingTable.javaNameFirstLower}Table.getTableModel().insertRow();
      row.set${col.javaName}(builder.get${col.reference.column.javaName}());
      row.set${refColumn.javaName}(otherBuilder.get${remoteKey}());
      List<${clsRef}> otherList = getOrCreateList(ref.${refColumn.reference.remoteName}List, threadScope);
      if(otherList.contains(this)) 
      {
        otherList.remove(this);
      }
    }
#else
## foreign reference
#set($refClsRef = ${referencingTable.javaName} + "Ref")
#set($verb = ${col.reference.remoteName})

    List<${refClsRef}> ${verb}ListScoped = getOrCreateList(${verb}List, threadScope);
    for (Iterator<${refClsRef}> it = ${verb}ListScoped.iterator(); it.hasNext(); )
    {
      ${refClsRef} ref = it.next();
      it.remove();	// remove iterator because if it will not resolve now, it will never
      RowBuilder_${referencingTable.javaName} otherBuilder = ref.getBuilder(scope);
      if (otherBuilder == null) 
      {
        continue;
      }
      
      otherBuilder.set${col.javaName}(builder.get${col.reference.column.javaName}());
      List<${clsRef}> otherList = getOrCreateList(ref.${col.reference.localName}List, threadScope);
      if (otherList.contains(this)) 
      {
        otherList.remove(this);
      }
    }
#end
#end
#end
#end
#end
  }
  
  ${clsRowbuilder} getBuilder(${clsScope} scope)
  {
    return builders.get(scope);
  }
  
#macro( addToList $list $item )
#if ($list.add($item))
#end
#end
#macro( addReference $refTable $verb $remoteVerb )
#set($refClsRef = ${refTable.javaName} + "Ref" )
  Map<${clsScope}, List<${refClsRef}>> ${verb}List = new HashMap<${clsScope}, List<${refClsRef}>>();

  // depending on relation type with or without ellipse (...)
  void ${verb}(${refClsRef} ... refs) {
    ${clsScope} scope = threadScope.get();
    ${clsRowbuilder} thisBuilder = getBuilder(scope);
    
    for (${refClsRef} ref : refs) 
    {
      RowBuilder_${refTable.javaName} otherBuilder = ref.getBuilder(scope);
      
      // check if both row builders exist to resolve relation
      if (thisBuilder != null && otherBuilder != null) 
      {
#foreach( $line in $resolveCode )
        $line
#end        
      }
      else {
        // at least one builder does not exist... at relation information
        // to the Refs where no builder exist.
        if (thisBuilder == null)
        {
          getOrCreateList(${verb}List, threadScope).add(ref);
        }
        if (otherBuilder == null) {
          getOrCreateList(ref.${remoteVerb}List, threadScope).add(this);
        }
      }
    }
  }

#end  
#if ( !${model.isAssociativeTable()} )
#foreach( $col in $model.columns )
#if( $col.reference )
#set($resolveCode = [ "// simple reference" ] )
#addToList($resolveCode "thisBuilder.set${col.javaName}(otherBuilder.get${col.reference.column.javaName}());")
#addReference( $col.reference.table ${col.reference.localName} ${col.reference.remoteName} $resolveCode )
#end
#end
#foreach( $referencingTable in $model.dataSet.tables )
#foreach( $col in $referencingTable.columns )
#if( ${col.isReferencingTable($model)} )
#if ( ${referencingTable.isAssociativeTable()} )
#set($resolveCode = [ "// associative table" ] )
#set($refColumn = ${referencingTable.getReferencingColumn($model)})
#foreach ($c in $referencingTable.columns)
#if ($c != $col)
#set($remoteKey = $c.reference.column.javaName) 
#end
#end
#addToList($resolveCode "RowBuilder_${referencingTable.javaName} builder = scope.${referencingTable.javaNameFirstLower}Table.getTableModel().insertRow();")
#addToList($resolveCode "builder.set${col.javaName}(thisBuilder.get${col.reference.column.javaName}());")
#addToList($resolveCode "builder.set${refColumn.javaName}(otherBuilder.get${remoteKey}());")
#addReference( ${referencingTable.getAssociatedTable($model)} ${col.reference.remoteName} ${referencingTable.getReferencingColumn($model).reference.remoteName} $resolveCode)
#else
#set($resolveCode = [ "// foreign reference" ] )
#addToList($resolveCode "otherBuilder.set${col.javaName}(thisBuilder.get${col.reference.column.javaName}());")
#addReference( ${col.table} ${col.reference.remoteName} ${col.reference.localName} $resolveCode )
#end
#end
#end
#end
#end

}

