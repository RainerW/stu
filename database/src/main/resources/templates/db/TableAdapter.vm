#set($names             = ${model.dataSet.names})
#set($filename          = ${names.getTableAdapterClass($model)})
#set($clsAdapter        = ${names.getTableAdapterClass($model)})
#set($clsTable          = ${names.getTableClass($model)})
#set($clsBuilder        = ${names.builderClass})
#set($clsRowbuilder     = ${names.getRowBuilderClass($model)})
#set($clsRef            = ${names.getRefClass($model)})
#set($clsTableFindWhere = ${names.getFindWhereClass($model)})
#set($clsTableGetWhere  = ${names.getGetWhereClass($model)})
#set($clsRowcollection  = ${names.getRowCollectionClass($model)})
#set($javaDocSep        = "#")
#set($package           = ${model.package} )
#if( $package && $package.length() != 0 )
package ${package};
#end
#if( !${model.isAssociativeTable()})

import com.google.common.base.Optional;
#end

import com.seitenbau.testing.dbunit.dsl.CastUtil;
import com.seitenbau.testing.dbunit.dsl.ColumnBinding;
import com.seitenbau.testing.dbunit.dsl.DatabaseReference;
import com.seitenbau.testing.dbunit.dsl.NoValue;
import com.seitenbau.testing.dbunit.dsl.RefColumnBinding;
import com.seitenbau.testing.dbunit.dsl.TableParser;
import com.seitenbau.testing.dbunit.dsl.TableParserAdapter;
import com.seitenbau.testing.dbunit.dsl.TableParserCallback;
import com.seitenbau.testing.dbunit.generator.ColumnMetaData;
import com.seitenbau.testing.dbunit.generator.DataType;
import com.seitenbau.testing.dbunit.modifier.IDataSetModifier;
#if( !${model.isAssociativeTable()})
import com.seitenbau.testing.dbunit.util.NullCompatibleEquivalence;
#end
import com.seitenbau.testing.util.Action;
import com.seitenbau.testing.util.Filter;
import com.seitenbau.testing.util.Future;

import groovy.lang.Closure;
#if( !${model.isAssociativeTable()})

import java.util.HashSet;
import java.util.Set;
#end

###if( $model.package && $model.package.length() != 0 )
##import ${model.package}.${model.dataSet.name}DataSet;
###end
import ${model.package}.${clsTable}.${clsRowcollection};
import ${model.package}.${clsTable}.${clsTableFindWhere};
import ${model.package}.${clsTable}.${clsTableGetWhere};
#foreach( $table in $model.associatedTables )
import ${model.package}.${names.getTableClass($table)}.${names.getRowBuilderClass($table)};
#end


public class ${clsAdapter} {

  /**
   * Do not set a value. (To remove a value use <i>null</i>)
   */
  public final NoValue _ = new NoValue();

  /**
   * Column Header for ${model.javaName} table.
   * <p>
   * Data Type: ${names.getRefClass($model)}
   */
  public final ColumnBinding<${clsRowbuilder}, ${clsTableGetWhere}> REF = new RefColumnBinding<${clsRowbuilder}, ${clsTableGetWhere}>();

#foreach( $col in $model.columns )
#macro( comments )
  /**
   * Column Header for ${model.javaName} table.
#if( ${col.description} )
   * <p>
   * ${col.description}
#end
   * <p>
   * Data Type: {@code ${col.javaType}}
#if( ${col.reference} )
   * or {@code ${names.getRefClass($col.reference.column.table)}
#end
   * <br>   
   * Database Type: ${col.type}
   * 
   */
#end
#comments()   
  public final ColumnBinding<${clsRowbuilder}, ${clsTableGetWhere}> ${col.name} = create${col.javaName}Binding();

## check if column is an identifier
#if ( ${col.truncatedReferenceName} )
#set( $shortname  = ${col.truncatedReferenceName} )
#comments()   
  public final ColumnBinding<${clsRowbuilder}, ${clsTableGetWhere}> ${shortname} = ${col.name};

#end
#end
  private final ${clsBuilder} _builder;

  private final ${clsTable} _table;

  private final TableParserAdapter<${clsRowbuilder}, ${clsTableGetWhere}, ${clsRef}> _adapter = new TableAdapter();

  /**
   * Allows searching for one or more rows specified by a column value.
   * findWhere assumes that it is used to search for existing rows. An
   * exception will be thrown if no matching row was found. Use getWhere
   * or find to avoid this behavior.
   * @see ${javaDocSep}getWhere
   * @see ${javaDocSep}find(Closure)
   * @see ${javaDocSep}find(Filter)
   */
  public final ${clsTableFindWhere} findWhere;

  /**
   * Allows searching for a row specified by a column value.
   * The first matching row is returned. Does not throw an
   * exception, if no element is found.
   * @see ${javaDocSep}findWhere
   * @see ${javaDocSep}find(Closure)
   * @see ${javaDocSep}find(Filter)
   */
  public final ${clsTableGetWhere} getWhere;

  ${clsAdapter}(${clsBuilder} builder, ${clsTable} table)
  {
    _builder = builder;
    _table = table;
    findWhere = _table.findWhere;
    getWhere = _table.getWhere;
  }

  public static ColumnMetaData getColumnMetaData(String column)
  {
    return ${model.package}.${clsAdapter}.getColumnMetaData(column);
  }

  /**
   * Parses the rows of a ${model.javaName} table. Supported columns are:
   * <ul>
   *   <li><strong>{@code REF}</strong>: {@code ${names.getRefClass($model)}}</li>
#foreach( $col in $model.columns )
#set( $shortname  = "" )
#if ( ${col.truncatedReferenceName} )
#set( $shortname  = " (alias: <strong>{@code " + ${col.truncatedReferenceName} + "}</strong>)")
#end
   *   <li> <strong>{@code ${col.name}}</strong>$shortname: {@code ${col.javaType}}
#end
   * </ul>
   * The table has to start with a header row, but there can be more
   * headers within one block.
   *
   * <p>Example usage:
   * <pre>
   * ${names.getTableAdapterVariable($model)}.rows {
   *   REF #foreach( $col in $model.columns )| ${col.name} #end // header 
   *   ...
   * }
   * </pre>
   *
   * @param rows The table data
   */
  public void rows(Closure<?> rows)
  {
    TableParserCallback<${clsRowbuilder}, ${clsTableGetWhere}, ${clsRef}> callback = 
        new TableParserCallback<${clsRowbuilder}, ${clsTableGetWhere}, ${clsRef}>(_adapter);
    TableParser.parseTable(rows, this, callback);
  }
  
  public int getRowCount() 
  {
    return _table.getRowCount();
  }

  public ${clsRowbuilder} insertRow()
  {
    return _table.insertRow();
  }
#if( ${model.dataSet.isModelClassGeneration()} )

  public ${clsRowbuilder} insertRow(${model.javaName}Model row)
  {
    return _table.insertRow(row);
  }
#end

  public ${clsRowbuilder} insertRowAt(int index)
  {
    return _table.insertRowAt(index);
  }

  public ${clsRowbuilder} insertRow(${clsRowbuilder} theRow)
  {
    return _table.insertRow(theRow);
  }

  /**
   * Remove a row from the builder by the given index.
   *
   * @return the deleted row
   */
  public ${clsRowbuilder} deleteRow(int index)
  {
    return _table.deleteRow(index);
  }

  /**
   * Remove a row from the data set
   */
  public ${clsRowbuilder} deleteRow($clsRef ref)
  {
    return _table.deleteRow(ref);
  }

  /**
   * Remove a row from the builder
   * @return the deleted row itself
   */
  public ${clsRowbuilder} deleteRow(${clsRowbuilder} rowToDelete)
  {
    return _table.deleteRow(rowToDelete);
  }
#if( ${model.isAssociativeTable()})
#set( $tab1 = ${model.columns.get(0).reference.table} )
#set( $tab2 = ${model.columns.get(1).reference.table} )
#set( $ref1 = ${names.getRefVariable($tab1)} )
#set( $ref2 = ${names.getRefVariable($tab2)} )

  public ${clsRowbuilder} deleteAssociation(${names.getRefClass($tab1)} ${ref1}, ${names.getRefClass($tab2)} ${ref2})
  {
    return _table.deleteAssociation(${ref1}, ${ref2});
  }

  public ${clsRowbuilder} deleteAssociation(${names.getRefClass($tab2)} ${ref2}, ${names.getRefClass($tab1)} ${ref1})
  {
    return _table.deleteAssociation(${ref2}, ${ref1});
  }
  
  public ${clsRowbuilder} deleteAllAssociations(${names.getRefClass($tab1)} ref)
  {
    return _table.deleteAllAssociations(ref);
  }

  public ${clsRowbuilder} deleteAllAssociations(${names.getRefClass($tab2)} ref)
  {
    return _table.deleteAllAssociations(ref);
  }
  
#end

  /**
   * Creates a new row but does not add it to the table
   */
  public ${clsRowbuilder} newRow()
  {
    return _table.newRow();
  }

  /**
   * Delivers a collection of rows matching to a filter.
   * @param filter The used filter
   * @return The collection of rows, may return an empty list
   * @see ${javaDocSep}find(Closure)
   * @see ${javaDocSep}findWhere
   * @see ${javaDocSep}getWhere
   */
  public ${clsRowcollection} find(Filter<${clsRowbuilder}> filter)
  {
    return _table.find(filter);
  }

  /**
   * Delivers a collection of rows matching to a filter.
   * @param filter A Groovy Closure with an argument of type ${clsRowbuilder}, returning a boolean
   * @return The collection of rows, may return an empty list
   * @see ${javaDocSep}find(Filter)
   * @see ${javaDocSep}findWhere
   * @see ${javaDocSep}getWhere
   */
  public ${clsRowcollection} find(Closure<Boolean> filter)
  {
    final Closure<Boolean> localFilter = filter;
    return _table.find(new Filter<${clsRowbuilder}>()
      {
        @Override
        public boolean accept(${clsRowbuilder} row)
        {
          return localFilter.call(row);
        }
      });
  }

  public void foreach(Action<${clsRowbuilder}> action)
  {
    _table.foreach(action);
  }

  public void foreach(Closure<?> action)
  {
    final Closure<?> localAction = action;
    _table.foreach(new Action<${clsRowbuilder}>()
      {
        @Override
        public void call(${clsRowbuilder} row)
        {
          localAction.call(row);
        }
      });
  }

  private class TableAdapter implements TableParserAdapter<${clsRowbuilder}, ${clsTableGetWhere}, ${clsRef}>
  {
    @Override
    public ${clsRowbuilder} insertRow() 
    {
      return _table.insertRow();
    }
  
    @Override
    public ${clsTableGetWhere} getWhere()
    {
      return _table.getWhere;
    }

    @Override
    public void bindToDataSet(${clsRef} reference, ${clsRowbuilder} row)
    {
      reference.setBuilder(_builder, row);
    }

    @Override
    public ${clsRowbuilder} getRowByReference(${clsRef} reference)
    {
      return reference.getBuilder(_builder);
    }

    @Override
    public String getTableName()
    {
      return "${model.javaName}";
    }
    
  };

#foreach( $col in $model.columns )

  private ColumnBinding<${clsRowbuilder}, ${clsTableGetWhere}> create${col.javaName}Binding() 
  {
    return new ColumnBinding<${clsRowbuilder}, ${clsTableGetWhere}>()
    {
      @Override
      public void set(${clsRowbuilder} row, Object value)
      {
#if ( ${col.isIdentifierColumn()} )
        if (definedIdsSet.contains(row) && !NullCompatibleEquivalence.equals(row.get${col.javaName}(), value)) {
          throw new IllegalStateException("Cannot reset column id [" + row.get${col.javaName}() + " vs " + value + "]");
        }
        definedIdsSet.add(row);
#end
        if (valueMustBeSetRaw(value)) 
        {
          row.set${col.javaName}Raw(value);
        } else {
          row.set${col.javaName}((${col.javaType})CastUtil.cast(value, ${col.type}));
        }
      }
#if ( ${col.reference} )
#set( $refTable = ${col.reference.table} )

      @Override
      public void setReference(${clsRowbuilder} row, DatabaseReference ref)
      {
        ${names.getRefClass($refTable)} reference = (${names.getRefClass($refTable)})ref;
        ${names.getRowBuilderClass($refTable)} referenceBuilder = reference.getBuilder(_builder);
        if (referenceBuilder != null)
        {
          final ${col.reference.column.javaType} value = referenceBuilder.get${col.reference.javaName}();
          row.set${col.javaName}(value);
        } else {
          row.set${col.javaName}Raw(ref);
        }
      }
#end
#if ( ${col.isIdentifierColumn()} )

      @Override
      public Optional<${clsRowbuilder}> getWhere(${clsTableGetWhere} getWhere, Object value)
      {
        return getWhere.${col.javaNameFirstLower}((${col.javaType})CastUtil.cast(value, ${col.type}));
      }

      @Override
      public boolean isIdentifierColumn()
      {
        return true;
      }
    
      private Set<${clsRowbuilder}> definedIdsSet = new HashSet<${clsRowbuilder}>();
#else

      @Override
      public void setFutureValue(${clsRowbuilder} row, Future<Object> futureValue)
      {
        row.set${col.javaName}Raw(futureValue);
      }
#end
      
      @Override
      public DataType getDataType()
      {
        return ${col.type};
      }

    };
  }
#end

  private boolean valueMustBeSetRaw(Object value)
  {
    return (value instanceof DatabaseReference) || (value instanceof IDataSetModifier);
  }

}

